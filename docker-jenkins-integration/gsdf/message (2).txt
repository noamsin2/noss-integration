#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct node {
    char* token;
    struct node* left;
    struct node* right;
} node;

typedef enum {
    INT,
    FLOAT,
    DOUBLE,
    CHAR,
    BOOL,
    STRING,
    INT_PTR,
    CHAR_PTR,
    DOUBLE_PTR,
    FLOAT_PTR
} type;

typedef struct Symbol {
    char name[50];
    type symbol_type;
    int is_function;
    int is_static;
    int is_public;
    int num_args;
    type return_type;
    struct Symbol* next;
} Symbol;

typedef struct Scope {
    Symbol* first;
    struct Scope* father;
} Scope;

// Helper functions to manage the symbol table
Scope* create_scope(Scope* father) {
    Scope* new_scope = (Scope*)malloc(sizeof(Scope));
    new_scope->father = father;
    new_scope->first = NULL;
    return new_scope;
}

Symbol* create_symbol(char* name, type symbol_type, int is_function, int is_static, int is_public, int num_args, type return_type) {
    Symbol* new_symbol = (Symbol*)malloc(sizeof(Symbol));
    strcpy(new_symbol->name, name);
    new_symbol->symbol_type = symbol_type;
    new_symbol->is_function = is_function;
    new_symbol->is_static = is_static;
    new_symbol->is_public = is_public;
    new_symbol->num_args = num_args;
    new_symbol->return_type = return_type;
    new_symbol->next = NULL;
    return new_symbol;
}

void add_symbol(Scope* scope, Symbol* symbol) {
    symbol->next = scope->first;
    scope->first = symbol;
}

Symbol* find_symbol(Scope* scope, char* name) {
    Scope* current_scope = scope;
    while (current_scope != NULL) {
        Symbol* current_symbol = current_scope->first;
        while (current_symbol != NULL) {
            if (strcmp(current_symbol->name, name) == 0) {
                return current_symbol;
            }
            current_symbol = current_symbol->next;
        }
        current_scope = current_scope->father;
    }
    return NULL;
}

// Semantic analysis checks
bool check_main_function(Scope* global_scope) {
    Symbol* main_func = find_symbol(global_scope, "main");
    if (main_func == NULL) {
        printf("Error: main function is missing.\n");
        return false;
    }
    if (!(main_func->is_function && main_func->is_static && main_func->is_public && main_func->num_args == 0 && main_func->return_type == VOID)) {
        printf("Error: main function must be public static void and take no arguments.\n");
        return false;
    }
    return true;
}

bool check_unique_functions(Scope* scope) {
    Symbol* current = scope->first;
    while (current != NULL) {
        if (current->is_function) {
            Symbol* runner = current->next;
            while (runner != NULL) {
                if (runner->is_function && strcmp(current->name, runner->name) == 0) {
                    printf("Error: Duplicate function name '%s' in the same scope.\n", current->name);
                    return false;
                }
                runner = runner->next;
            }
        }
        current = current->next;
    }
    return true;
}

bool check_unique_variables(Scope* scope) {
    Symbol* current = scope->first;
    while (current != NULL) {
        if (!current->is_function) {
            Symbol* runner = current->next;
            while (runner != NULL) {
                if (!runner->is_function && strcmp(current->name, runner->name) == 0) {
                    printf("Error: Duplicate variable name '%s' in the same scope.\n", current->name);
                    return false;
                }
                runner = runner->next;
            }
        }
        current = current->next;
    }
    return true;
}

bool check_function_definitions(Scope* global_scope, char* function_name) {
    if (find_symbol(global_scope, function_name) == NULL) {
        printf("Error: Function '%s' is used before it is defined.\n", function_name);
        return false;
    }
    return true;
}

bool check_variable_definitions(Scope* scope, char* variable_name) {
    if (find_symbol(scope, variable_name) == NULL) {
        printf("Error: Variable '%s' is used before it is defined.\n", variable_name);
        return false;
    }
    return true;
}

bool check_function_arguments(Scope* global_scope, char* function_name, int actual_args_count) {
    Symbol* function = find_symbol(global_scope, function_name);
    if (function == NULL) return false;

    if (function->num_args != actual_args_count) {
        printf("Error: Function '%s' called with incorrect number of arguments.\n", function_name);
        return false;
    }
    return true;
}

// Main semantic analysis function
void check_tree(node* root, Scope* sc) {
    if (root == NULL) return;

    // Perform checks based on the token of the node
    if (strcmp(root->token, "function") == 0) {
        // Assume node->left is the function name and node->right is the return type and args
        Symbol* func = create_symbol(root->left->token, VOID, 1, 1, 1, 0, VOID); // Simplified
        add_symbol(sc, func);
        if (!check_unique_functions(sc)) {
            exit(1); // Exit if there's a duplicate function
        }
    } else if (strcmp(root->token, "variable") == 0) {
        // Assume node->left is the variable name and node->right is the type
        Symbol* var = create_symbol(root->left->token, INT, 0, 0, 0, 0, INT); // Simplified
        add_symbol(sc, var);
        if (!check_unique_variables(sc)) {
            exit(1); // Exit if there's a duplicate variable
        }
    } else if (strcmp(root->token, "function_call") == 0) {
        if (!check_function_definitions(sc, root->left->token)) {
            exit(1); // Exit if the function is not defined
        }
        // Assuming arg count is stored in some way in the node
        if (!check_function_arguments(sc, root->left->token, 0)) { // Simplified
            exit(1); // Exit if the function is called with incorrect arguments
        }
    } else if (strcmp(root->token, "variable_usage") == 0) {
        if (!check_variable_definitions(sc, root->left->token)) {
            exit(1); // Exit if the variable is not defined
        }
    } else if (strcmp(root->token, "if_statement") == 0 || strcmp(root->token, "while_statement") == 0) {
        if (!check_boolean_expression(root->left)) {
            printf("Error: Condition in '%s' is not a boolean expression.\n", root->token);
            exit(1);
        }
    } else if (strcmp(root->token, "assignment") == 0) {
        if (!check_assignment_types(sc, root)) {
            exit(1); // Exit if the assignment types are incorrect
        }
    }

    // Recursively process children
    check_tree(root->left, sc);
    check_tree(root->right, sc);
}

// Helper function to check if an expression is boolean
bool check_boolean_expression(node* expr) {
    // Check if the expression evaluates to a boolean type
    // This is a simplified check; actual implementation will depend on the full type system
    return strcmp(expr->token, "BOOL") == 0;
}

// Helper function to check assignment types
bool check_assignment_types(Scope* sc, node* node) {
    node* left = node->left;  // Left-hand side of the assignment
    node* right = node->right; // Right-hand side of the assignment

    Symbol* left_var = find_symbol(sc, left->token);
    if (left_var == NULL) {
        printf("Error: Variable '%s' is not defined.\n", left->token);
        return false;
    }

    // Assuming that right->token gives the type as a string, this is simplified
    if (left_var->symbol_type != INT) {
        printf("Error: Type mismatch in assignment to '%s'.\n", left->token);
        return false;
    }

    return true;
}

// Example usage
int main() {
    // Create a global scope
    Scope* global_scope = create_scope(NULL);

    // Example tree nodes (In a real scenario, these would be generated by the parser)
    node func_node;
    func_node.token = "function";
    node func_name;
    func_name.token = "main";
    func_node.left = &func_name;
    func_node.right = NULL;

    node var_node;
    var_node.token = "variable";
    node var_name;
    var_name.token = "x";
    var_node.left = &var_name;
    var_node.right = NULL;

    // Build the syntax tree (In reality, this would be done by the parser)
    node root;
    root.token = "program";
    root.left = &func_node;
    root.right = &var_node;

    // Perform semantic checks and populate the symbol table
    check_tree(&root, global_scope);

    // Check the global scope
    Symbol* symbol = global_scope->first;
    while (symbol != NULL) {
        printf("Name: %s, Type: %d\n", symbol->name, symbol->symbol_type);
        symbol = symbol->next;
    }

    return 0;
}
